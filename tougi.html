<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バトルシミュレーション</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        h1 {
            text-align: center;
        }

        form {
            margin-bottom: 20px;
        }

        label {
            font-size: 14px;
            display: inline-block;
            width: 120px;
            /* ラベルの幅を統一 */
        }

        input {
            margin-bottom: 10px;
            font-size: 14px;
            width: 150px;
            /* 入力ボックスの幅を統一 */
        }

        #container {
            display: flex;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }

        .player_form {
            width: 45%;
        }

        .player_form div {
            margin-bottom: 10px;
        }

        #button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 20px auto;
            display: block;
        }

        #result {
            margin-top: 20px;
        }

        #battle_log {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            background-color: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            height: 400px;
            /* ログ画面の高さを増加 */
            overflow-y: scroll;
            width: 100%;
            /* 幅を調整 */
            font-size: 14px;
            /* フォントサイズを少し大きく */
        }

        #checkbox_container {
            display: inline-flex;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
        }

        #checkbox_container label {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s, box-shadow 0.2s;
            width: 10em;
        }

        #checkbox_container label:hover {
            background-color: #f0f0f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #checkbox_container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }

        .range-label {
            font-size: 14px;
            display: inline-block;
            width: 8em;
        }

        .range-container label {
            display: flex;
            align-items: center;
            padding: 5px 5px 0px 5px;
            width: 1em;
        }

        .range-container input {
            width: 1em;
        }

        .range-container {
            display: flex;
            justify-content: left;
            align-items: center;
            gap: 10px;
            height: 3em;
        }

        .range-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>

<body>
    <h1>バトルシミュレーション</h1>

    <div id="container">
        <!-- プレイヤー1の入力フォーム -->
        <div class="player_form">
            <h2>プレイヤー1</h2>
            <form id="player1_form">
                <div><label for="player1_name">名前: </label><input type="text" id="player1_name" value="プレイヤー1" required>
                </div>
                <div><label for="player1_hp">HP: </label><input type="number" id="player1_hp" value="100" required>
                </div>
                <div><label for="player1_ap">AP: </label><input type="number" id="player1_ap" value="10" required></div>
                <div><label for="player1_attack">主攻撃: </label><input type="number" id="player1_attack" value="20"
                        required></div>
                <div><label for="player1_subAttack">副攻撃: </label><input type="number" id="player1_subAttack" value="5"
                        required></div>
                <div><label for="player1_speed">速度: </label><input type="number" id="player1_speed" value="10" required>
                </div>
                <div><label for="player1_critical">クリティカル: </label><input type="number" id="player1_critical" value="5"
                        required></div>
                <div><label for="player1_fumble">ファンブル: </label><input type="number" id="player1_fumble" value="15"
                        required></div>
                <div><label for="player1_drama">ドラマ: </label><input type="number" id="player1_drama" value="10"
                        required></div>
                <div><label for="player1_hit">命中: </label><input type="number" id="player1_hit" value="10" required>
                </div>
                <div><label for="player1_evasion">回避: </label><input type="number" id="player1_evasion" value="5"
                        required></div>
                <div><label for="player1_defense">防御: </label><input type="number" id="player1_defense" value="10"
                        required></div>
                <div><label for="player1_resistance">抵抗: </label><input type="number" id="player1_resistance" value="10"
                        required></div>
                <div><label for="player1_mobility">機動力: </label><input type="number" id="player1_mobility" value="4"
                        required></div>
                <div><span class="range-label">通常攻撃射程：</span></div>
                <div class="range-container">
                    <div class="range-item">
                        <label for="close">至</label>
                        <input type="checkbox" id="player1_attack_range_check_0" name="attackRange" checked>
                    </div>
                    <div class="range-item">
                        <label for="near">近</label>
                        <input type="checkbox" id="player1_attack_range_check_1" name="attackRange">
                    </div>
                    <div class="range-item">
                        <label for="middle">中</label>
                        <input type="checkbox" id="player1_attack_range_check_2" name="attackRange">
                    </div>
                    <div class="range-item">
                        <label for="far">遠</label>
                        <input type="checkbox" id="player1_attack_range_check_3" name="attackRange" checked>
                    </div>
                    <div class="range-item">
                        <label for="ultra">超</label>
                        <input type="checkbox" id="player1_attack_range_check_4" name="attackRange" value="middle">
                    </div>
                </div>
            </form>
        </div>

        <!-- プレイヤー2の入力フォーム -->
        <div class="player_form">
            <h2>プレイヤー2</h2>
            <form id="player2_form">
                <div><label for="player2_name">名前: </label><input type="text" id="player2_name" value="プレイヤー2" required>
                </div>
                <div><label for="player2_hp">HP: </label><input type="number" id="player2_hp" value="100" required>
                </div>
                <div><label for="player2_ap">AP: </label><input type="number" id="player2_ap" value="10" required></div>
                <div><label for="player2_attack">主攻撃: </label><input type="number" id="player2_attack" value="20"
                        required></div>
                <div><label for="player2_subAttack">副攻撃: </label><input type="number" id="player2_subAttack" value="5"
                        required></div>
                <div><label for="player2_speed">速度: </label><input type="number" id="player2_speed" value="10" required>
                </div>
                <div><label for="player2_critical">クリティカル: </label><input type="number" id="player2_critical" value="5"
                        required></div>
                <div><label for="player2_fumble">ファンブル: </label><input type="number" id="player2_fumble" value="15"
                        required></div>
                <div><label for="player2_drama">ドラマ: </label><input type="number" id="player2_drama" value="10"
                        required></div>
                <div><label for="player2_hit">命中: </label><input type="number" id="player2_hit" value="10" required>
                </div>
                <div><label for="player2_evasion">回避: </label><input type="number" id="player2_evasion" value="5"
                        required></div>
                <div><label for="player2_defense">防御: </label><input type="number" id="player2_defense" value="10"
                        required></div>
                <div><label for="player2_resistance">抵抗: </label><input type="number" id="player2_resistance" value="10"
                        required></div>
                <div><label for="player2_mobility">機動力: </label><input type="number" id="player2_mobility" value="4"
                        required></div>
                <div><span class="range-label">通常攻撃射程：</span></div>
                <div class="range-container">
                    <div class="range-item">
                        <label for="close">至</label>
                        <input type="checkbox" id="player2_attack_range_check_0" name="attackRange" checked>
                    </div>
                    <div class="range-item">
                        <label for="near">近</label>
                        <input type="checkbox" id="player2_attack_range_check_1" name="attackRange">
                    </div>
                    <div class="range-item">
                        <label for="middle">中</label>
                        <input type="checkbox" id="player2_attack_range_check_2" name="attackRange">
                    </div>
                    <div class="range-item">
                        <label for="far">遠</label>
                        <input type="checkbox" id="player2_attack_range_check_3" name="attackRange" checked>
                    </div>
                    <div class="range-item">
                        <label for="ultra">超</label>
                        <input type="checkbox" id="player2_attack_range_check_4" name="attackRange">
                    </div>
                </div>
            </form>
        </div>
    </div>

    <div id="initial_range_meter_container"><label for="initial_range_meter">開始時距離(m): </label><input type="number"
            id="initial_range_meter" min="0" value="30" required>
        </select></div>

    <button onclick="startBattle()">バトル開始</button>
    <!-- ログをクリアするボタン -->
    <button id="clear_log_button">ログをクリア</button>
    <div id="checkbox_container">
        <label for="result_check">
            <input type="checkbox" id="result_check" name="result_check" checked>
            勝敗判定を行う
        </label>
    </div>

    <h2>バトル結果</h2>
    <div id="result"></div>

    <h2>バトルログ</h2>
    <div id="battle_log"></div>
    <script>
        // ログをクリアする関数
        function clearBattleLog() {
            const logArea = document.getElementById('battle_log');
            logArea.innerHTML = ''; // ログ内容を空にする
        }

        // ログをクリアするボタンのイベントリスナーを追加
        document.getElementById('clear_log_button').addEventListener('click', clearBattleLog);

        let rangeMeter;

        // レンジに対応する距離範囲を定義
        const rangeConditions = [
            distance => distance >= 0 && distance <= 3,      // 至近距離
            distance => distance >= 0 && distance <= 10,     // 近距離
            distance => distance >= 0 && distance <= 20,     // 中距離
            distance => distance >= 20 && distance <= 30,    // 遠距離
            distance => distance >= 30 && distance <= 40     // 超遠距離
        ];

        // レンジごとの補正を定義
        const rangeFix = {
            0: { 0: 10 },                          // 至近距離の補正
            1: { 0: 7, 1: 7 },                     // 近距離の補正
            2: { 0: 5, 1: 5, 2: 10 },              // 中距離の補正
            3: { 0: -10, 1: -10, 2: 5, 3: 5 },     // 遠距離の補正
            4: { 2: -10, 3: 5, 4: 5 }              // 超遠距離の補正
        };

        // レンジごとの適正距離を定義
        const optimalTargetDistance = {
            normal: {
                0: 0,
                1: 10,
                2: 20,
                3: 30,
                4: 40,
            },
            // 近めで戦う(不使用)
            near: {
                0: 0,
                1: 4,
                2: 11,
                3: 21,
                4: 31,
            },
            // 離れて戦う(不使用)
            far: {
                0: 3,
                1: 10,
                2: 20,
                3: 30,
                4: 40,
            }
        }

        class Character {
            constructor(name, hp, mainAttack, subAttack, speed, critical, fumble, drama, hit, evasion, defense, resistance, mobility, compatibleRange) {
                this.name = name;
                this.initialHp = hp;
                this.hp = hp;
                this.mainAttack = mainAttack;
                this.subAttack = subAttack;
                this.speed = speed;
                this.critical = critical;
                this.fumble = fumble;
                this.drama = drama;
                this.hit = hit;
                this.evasion = evasion;
                this.defense = defense;
                this.resistance = resistance;
                this.mobility = mobility;
                this.alive = true;
                this.passed = false;
                this.actionPoints = 0;
                this.yojoPoints = 0;
                this.dramaEnhanceCount = 0;
                this.cleanHitOverCountForJudge = 0;
                this.damageScoreForJudge = 0;
                this.judgePoints = 0;
                this.nextAction = null;
                this.compatibleRange = compatibleRange;
                this.rangeHitFix;
            }

            // ダメージを受けるメソッド
            takeDamage(damage, trueDamage, defenceFumble) {
                if (!defenceFumble) {
                    let defenseChance = Math.random() * 100;
                    if (defenseChance >= (100 - this.defense) && defenseChance > this.fumble) {
                        damage *= 0.3;
                        log(`${this.name}は防御技術でダメージを軽減しました！`);
                    }
                }

                let resistanceChance = Math.random() * 100;
                if (resistanceChance >= (100 - this.resistance) && resistanceChance > this.fumble) {
                    log(`${this.name}は状態異常に対する抵抗が発動しました！`);
                }

                damage = Math.round(damage + trueDamage);

                this.hp -= damage;
                log(`${this.name}は${damage}ダメージを受けました！\n`);

                if (this.hp <= 0) {
                    let dramaChance = Math.random() * 100;
                    // 数字が上回った=以上と解釈。>の可能性もあり
                    if (dramaChance >= (100 - this.drama) && dramaChance > this.fumble) {
                        this.hp = 1;
                        if (this.dramaEnhanceCount < 10) {
                            this.critical += 1;
                            this.speed += 20;
                            this.dramaEnhanceCount += 1;
                            log(`${this.name}はドラマ補正でHP1で踏みとどまり、クリティカルと速度が増加しました！`);
                        } else {
                            log(`${this.name}はドラマ補正でHP1で踏みとどまりました！`);
                        }
                    } else {
                        this.hp = 0;
                        this.alive = false;
                        log(`${this.name}は倒れました！`);
                    }
                }

                // 与えたダメージ量を返却
                return damage
            }

            // 行動可能かをチェック
            isAlive() {
                return this.alive;
            }

            // 行動力を決める
            rollInitiative() {
                let roll1 = Math.floor(Math.random() * 100) + 1;
                let roll2 = Math.floor(Math.random() * 100) + 1;
                this.actionPoints = this.speed + roll1 + roll2 + this.yojoPoints;
                log(`${this.name}のHP:${this.hp} 行動力:${this.actionPoints}(速度:${this.speed}+ダイス1:${roll1}+ダイス2:${roll2}+繰り越し分:${this.yojoPoints})`);
            }

            move() {
                // 現在の距離(m)
                let currentDistance = rangeMeter;
                // 移動可能な最大距離(m)
                let movableMeter = this.mobility * 10;

                // 目標地点を探索
                const findTargetPoint = (targetDistances, maxDistance) => {
                    let targetPoint = null;
                    let shortestDistance = Infinity;

                    // 射程ごとにチェック
                    for (const [range, target] of Object.entries(targetDistances)) {
                        const rangeIndex = parseInt(range, 10);
                        const distanceToTarget = Math.abs(target - rangeMeter);

                        if (
                            this.compatibleRange[rangeIndex] && // 対応可能な射程か
                            distanceToTarget <= maxDistance && // 移動可能距離内か
                            distanceToTarget < shortestDistance // 最短距離か
                        ) {
                            targetPoint = target;
                            shortestDistance = distanceToTarget;
                        }
                    }

                    return targetPoint;
                };

                // 最適な目標位置を探す
                const targetPosition = findTargetPoint(optimalTargetDistance.normal, movableMeter);

                // 条件を満たす位置が見つからなければ最大距離を移動
                if (targetPosition === null) {
                    rangeMeter = rangeMeter - movableMeter;
                } else {
                    rangeMeter = targetPosition;
                }
                log(`${this.name}は${rangeMeter}mの座標まで移動！`);
                this.actionPoints -= 20;
            }

            attack(target, consumeActionPoints) {
                this.attackPreProcess();
                // 射程外の場合は攻撃できない
                if (!this.withinNormalAttackRange()) {
                    return;
                }
                let attackCritical = false
                let attackFumble = false
                let defenceCritical = false
                let defenceFumble = false

                // ① 命中判定
                let roll = Math.floor(Math.random() * 100) + 1; // 100面ダイスを振る
                let hitChance = this.hit + roll; // 命中判定数値

                // ② 回避判定
                let evasionRoll = Math.floor(Math.random() * 100) + 1; // 回避判定用ダイスを振る
                let finalEvasion = evasionRoll + target.evasion; // 最終的な回避数値

                if (roll >= 100 - this.critical) {
                    attackCritical = true
                }
                if (roll <= this.fumble) {
                    attackFumble = true
                }
                if (roll >= 100 - target.critical) {
                    defenceCritical = true
                }
                if (roll <= target.fumble) {
                    defenceFumble = true
                }

                // ③ ログ出力: 命中ダイスと命中値、回避判定ダイスと回避値を表示
                log(`${this.name}が攻撃！ 命中判定: ${hitChance} (命中ダイス: ${roll}, 命中: ${this.hit})`);
                log(`${target.name}の回避判定: ${finalEvasion} (回避ダイス: ${evasionRoll}, 回避: ${target.evasion})`);

                // ④ 命中判定と回避判定を比較
                if (defenceCritical) {
                    // クリティカルでの完全回避の場合
                    log(`${target.name}はクリティカルで完全回避しました！`);
                } else if (attackFumble) {
                    // 自動失敗の場合
                    log(`${this.name}の攻撃は自動失敗しました。`);
                } else if (hitChance > finalEvasion) {
                    log(`${target.name}は回避に失敗し、攻撃が命中しました！`);

                    // ⑤ 再度ダイスを振ってヒット判定を行う
                    let secondRoll = Math.floor(Math.random() * 100) + 1; // 2回目の命中ダイスを振る
                    hitChance += secondRoll; // 命中判定に加算

                    // ⑥ 最終的な命中度を判定するためのダイス

                    let finalHitDegree = hitChance - finalEvasion; // 加算された最終命中度

                    // ログ出力: 最終命中度のダイス結果と最終的な命中度
                    log(`${this.name}の命中度判定ダイス: ${secondRoll}`);
                    log(`${this.name}の最終命中度数値: ${finalHitDegree} (命中判定: ${hitChance}, 命中度ダイス: ${secondRoll})`);

                    // ⑦ ヒットの種類を判定
                    let damage = 0;
                    let trueDamage = 0;
                    if (finalHitDegree <= 49 && !attackCritical) {
                        damage = this.mainAttack * (15 + secondRoll / 4) / 100 + this.subAttack;
                        target.resistance += 50;
                        log(`${this.name}はグレイズヒットで攻撃！`);
                    } else if (finalHitDegree <= 99 || (finalHitDegree <= 49 && attackCritical)) {
                        // 命中判定のクリティカル時はライトヒットを保証
                        damage = this.mainAttack * (30 + secondRoll / 2) / 100 + this.subAttack;
                        target.resistance += 30;
                        log(`${this.name}はライトヒットで攻撃！`);
                    } else if (finalHitDegree <= 149) {
                        if (attackCritical) {
                            damage = this.mainAttack;
                            trueDamage = this.subAttack * 3;
                        } else {
                            damage = this.mainAttack + this.subAttack;
                        }
                        target.resistance += 0;
                        target.drama -= 10;
                        log(`${this.name}はクリーンヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    } else if (finalHitDegree <= 199) {
                        if (attackCritical) {
                            damage = this.mainAttack * (1 + secondRoll / 200);
                            trueDamage = this.subAttack * (1 + secondRoll / 200) * 3;
                        } else {
                            damage = this.mainAttack * (1 + secondRoll / 200);
                            trueDamage = this.subAttack * (1 + secondRoll / 200);
                        }
                        target.resistance -= 25;
                        target.drama -= 20;
                        log(`${this.name}はハードヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    } else {
                        if (attackCritical) {
                            damage = this.mainAttack * (1 + secondRoll / 100);
                            trueDamage = this.subAttack * (1 + secondRoll / 100) * 3;
                        } else {
                            damage = this.mainAttack * (1 + secondRoll / 100);
                            trueDamage = this.subAttack * (1 + secondRoll / 100);
                        }
                        target.resistance -= 50;
                        target.drama -= 30;
                        log(`${this.name}はスマッシュヒットで攻撃！`);
                        this.cleanHitOverCountForJudge++;
                    }

                    // ダメージをターゲットに与える
                    this.damageScoreForJudge += target.takeDamage(damage, trueDamage, defenceFumble);

                } else if (hitChance <= finalEvasion) {
                    // 完全回避の場合
                    log(`${target.name}は完全回避しました！`);
                }
                this.actionPoints -= consumeActionPoints; // 攻撃に必要な行動力を消費

                this.attackPostProcess();
            }

            attackPreProcess() {
                this.applyRangeFix();
            }

            attackPostProcess() {
                this.applyRangeFix(true);
            }

            applyRangeFix(postProcess) {

                if (postProcess) {
                    this.hit -= this.rangeHitFix;
                    return;
                }

                // 現在の射程インデックスを特定
                const currentRangeIndex = rangeConditions.findIndex(condition => condition(rangeMeter));

                // 射程対応状況に基づき補正を適用
                for (const [weaponRange, fixes] of Object.entries(rangeFix)) {
                    const weaponRangeIndex = parseInt(weaponRange, 10);

                    // 現在の射程が対応していない場合はスキップ
                    if (!this.compatibleRange[weaponRangeIndex]) continue;

                    // 補正値を適用
                    for (const [targetRange, fixValue] of Object.entries(fixes)) {
                        const targetRangeIndex = parseInt(targetRange, 10);

                        if (targetRangeIndex === currentRangeIndex) {
                            this.rangeHitFix = fixValue;
                            this.hit += fixValue;
                        }
                    }
                }

                return this.hit;
            }

            halveProcess() {
                this.actionPoints = Math.floor(this.actionPoints / 2); // 行動力半減
                log(`${this.name}の残り行動力: ${this.actionPoints}\n`);
            }

            decideAction(targetPlayer) {

                const withinNormalAttackRange = this.withinNormalAttackRange();
                if (this.actionPoints >= 60) {
                    if (!withinNormalAttackRange) {
                        this.nextAction = '移動通常攻撃';
                    } else {
                        this.nextAction = '通常攻撃';
                    }
                }
                if (this.actionPoints < 60) {
                    if (!withinNormalAttackRange) {
                        // 現時点でこの行動値で取る行動を実装していないため持ち越す
                        // 相手が攻撃可能で射程内であれば移動で距離を離す処理を検討する余地あり
                        this.nextAction = '速度を持ち越す';
                    } else {
                        this.nextAction = '通常攻撃';
                    }
                }
                if (this.actionPoints < 40) {
                    // 現時点でこの行動値で取る行動を実装していないため持ち越す
                    // 相手が攻撃可能で射程内であれば移動で距離を離す処理を検討する余地あり
                    this.nextAction = '速度を持ち越す';
                }
                if (this.actionPoints < 20) {
                    this.nextAction = '速度を持ち越す';
                }
            }

            withinNormalAttackRange() {
                // 各射程で対応可能かどうかを確認
                const results = rangeConditions.map((condition, index) => condition(rangeMeter) && this.compatibleRange[index]);
                // 一つでもtrueがあれば対応可能、すべてfalseなら対応不可
                return results.some(result => result);
            }
        }

        let player1, player2;

        function log(message) {
            const battleLog = document.getElementById('battle_log');
            battleLog.textContent += message + '\n';
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        function startBattle() {
            player1 = new Character(
                document.getElementById('player1_name').value,
                parseInt(document.getElementById('player1_hp').value),
                parseInt(document.getElementById('player1_attack').value),
                parseInt(document.getElementById('player1_subAttack').value),
                parseInt(document.getElementById('player1_speed').value),
                parseInt(document.getElementById('player1_critical').value),
                parseInt(document.getElementById('player1_fumble').value),
                parseInt(document.getElementById('player1_drama').value),
                parseInt(document.getElementById('player1_hit').value),
                parseInt(document.getElementById('player1_evasion').value),
                parseInt(document.getElementById('player1_defense').value),
                parseInt(document.getElementById('player1_resistance').value),
                parseInt(document.getElementById('player1_mobility').value),
                {
                    0: document.getElementById('player1_attack_range_check_0').checked,
                    1: document.getElementById('player1_attack_range_check_1').checked,
                    2: document.getElementById('player1_attack_range_check_2').checked,
                    3: document.getElementById('player1_attack_range_check_3').checked,
                    4: document.getElementById('player1_attack_range_check_4').checked
                }
            );

            player2 = new Character(
                document.getElementById('player2_name').value,
                parseInt(document.getElementById('player2_hp').value),
                parseInt(document.getElementById('player2_attack').value),
                parseInt(document.getElementById('player2_subAttack').value),
                parseInt(document.getElementById('player2_speed').value),
                parseInt(document.getElementById('player2_critical').value),
                parseInt(document.getElementById('player2_fumble').value),
                parseInt(document.getElementById('player2_drama').value),
                parseInt(document.getElementById('player2_hit').value),
                parseInt(document.getElementById('player2_evasion').value),
                parseInt(document.getElementById('player2_defense').value),
                parseInt(document.getElementById('player2_resistance').value),
                parseInt(document.getElementById('player2_mobility').value),
                {
                    0: document.getElementById('player2_attack_range_check_0').checked,
                    1: document.getElementById('player2_attack_range_check_1').checked,
                    2: document.getElementById('player2_attack_range_check_2').checked,
                    3: document.getElementById('player2_attack_range_check_3').checked,
                    4: document.getElementById('player2_attack_range_check_4').checked,
                }
            );

            rangeMeter = Number(document.getElementById('initial_range_meter').value);

            log(`バトル開始！ ${player1.name} vs ${player2.name}`);

            const suspensionJudgeFlag = document.getElementById('result_check').checked; // 勝敗判定を行うかどうか

            let turn = 1;
            turnLoop: while (player1.isAlive() && player2.isAlive()) {

                if (turn >= 21 && suspensionJudgeFlag) {
                    break;
                }

                log(`\nターン ${turn}:`);
                player1.passed = false;
                player2.passed = false;

                // BS判定フェーズ
                // ダメージバッドステータスのダメージ処理
                // →バッドステータスの自然回復判定
                //【呪い】を受けていない状態で3回の自然回復判定を行うと、そのバッドステータスは消滅する

                // 速度決定フェーズ
                player1.rollInitiative();
                player2.rollInitiative();

                // 行動フェーズ
                let actPlayer, targetPlayer;

                while (!player1.passed && !player2.passed) {

                    // 行動者決定
                    if (player1.actionPoints > player2.actionPoints) {
                        actPlayer = player1;
                        targetPlayer = player2;
                    } else if (player2.actionPoints > player1.actionPoints) {
                        actPlayer = player2;
                        targetPlayer = player1;
                    } else {
                        if (Math.random() < 0.5) {
                            actPlayer = player1;
                            targetPlayer = player2;
                        } else {
                            actPlayer = player2;
                            targetPlayer = player1;
                        }
                    }

                    actPlayer.decideAction(targetPlayer);

                    switch (actPlayer.nextAction) {
                        case '移動通常攻撃': {
                            // 移動が必要な状況で移動
                            actPlayer.move();
                            actPlayer.attack(targetPlayer, 40);
                            if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                                break turnLoop;
                            }
                            actPlayer.halveProcess();
                            break;
                        }
                        case '通常攻撃': {
                            // 通常攻撃またはスキル
                            actPlayer.attack(targetPlayer, 40);
                            if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                                break turnLoop;
                            }
                            actPlayer.halveProcess();
                            break;
                        }
                        case '速度を持ち越す':
                        default: {
                            if (!actPlayer.passed) {
                                // 速度持ち越し処理
                                actPlayer.passed = true;
                                actPlayer.yojoPoints = actPlayer.actionPoints;
                                if (actPlayer.yojoPoints > actPlayer.speed) {
                                    actPlayer.yojoPoints = actPlayer.speed;
                                }
                                actPlayer.actionPoints = 0;
                            }
                            break;
                        }
                    }

                    if (!actPlayer.isAlive() || !targetPlayer.isAlive()) {
                        break turnLoop;
                    }
                }

                turn++;
            }
            let result = document.getElementById('result');
            if (player1.isAlive() && player2.isAlive()) {
                // 次の項目を1ポイントとし、20ターン経過時にポイントが高い方が勝者。それでも決着が付かない場合は引き分け。

                log(`20ターン終了時に両者生存のため勝敗判定に移行！`);

                // １．与ダメージの総数が多い方
                log(`与ダメージ総計`);
                log(`${player1.name}の与ダメージ総計は${player1.damageScoreForJudge}`);
                log(`${player2.name}の与ダメージ総計は${player2.damageScoreForJudge}`);
                if (player1.damageScoreForJudge > player2.damageScoreForJudge) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (player1.damageScoreForJudge < player2.damageScoreForJudge) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }

                // ２．クリーンヒット以上の回数が多い方
                log(`クリーンヒット以上の攻撃回数`);
                log(`${player1.name}のクリーンヒット以上の攻撃回数は${player1.cleanHitOverCountForJudge}`);
                log(`${player2.name}のクリーンヒット以上の攻撃回数は${player2.cleanHitOverCountForJudge}`);
                if (player1.cleanHitOverCountForJudge > player2.cleanHitOverCountForJudge) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (player1.cleanHitOverCountForJudge < player2.cleanHitOverCountForJudge) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }

                // ３．残HPの割合が多い方
                const player1HpPercentage = Math.round(player1.hp / player1.initialHp * 100);
                const player2HpPercentage = Math.round(player2.hp / player2.initialHp * 100);
                log(`残HP割合`);
                log(`${player1.name}のHPは${player1.hp}/${player1.initialHp}(${player1HpPercentage}%)`);
                log(`${player2.name}のHPは${player2.hp}/${player2.initialHp}(${player2HpPercentage}%)`);
                if (Math.round(player1.hp / player1.initialHp * 100) > Math.round(player2.hp / player2.initialHp * 100)) {
                    log(`${player1.name}に1点！`);
                    player1.judgePoints++;
                } else if (Math.round(player1.hp / player1.initialHp * 100) < Math.round(player2.hp / player2.initialHp * 100)) {
                    log(`${player2.name}に1点！`);
                    player2.judgePoints++;
                } else {
                    log(`互角！`);
                }


                log(`${player1.name}の合計ポイントは${player1.judgePoints}！`);
                log(`${player2.name}の合計ポイントは${player2.judgePoints}！`);
                log(`よって……`);
                // 結果の判定
                if (player1.judgePoints > player2.judgePoints) {
                    result.innerHTML = `${player1.name}の勝利！`;
                    return;
                } else if (player1.judgePoints < player2.judgePoints) {
                    result.innerHTML = `${player2.name}の勝利！`;
                    return;
                } else {
                    result.innerHTML = `引き分けです。`;
                    return;
                }
            }
            if ((!player1.isAlive() && !player2.isAlive()) || (player1.isAlive() && player2.isAlive())) {
                result.innerHTML = `引き分けです。`;
            } else if (!player1.isAlive()) {
                result.innerHTML = `${player2.name}の勝利！`;
            } else {
                result.innerHTML = `${player1.name}の勝利！`;
            }
        }
    </script>
</body>

</html>